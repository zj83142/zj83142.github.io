---
title: 积累一些常见的面试题
date: 2017-09-11 16:36:48
tags:
  笔记
categories:
  前端技能
---

### 前端安全与防范

1. XSS: 跨站脚本攻击

说明：它允许用户讲恶意代码植入到提供给其他用户使用的页面中，可以简单的理解为一种Javascript代码注入。

预防措施：
  - 过滤转义输入输出
  - 避免使用eval、new Function 等执行字符串的方法，除非确定字符串和用户输入五官
  - 使用cookie的httpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的
  - 使用innerHtml、document.write的时候，如果数据是用户输入的，那么需要对关键字符进行过滤与转义
<!-- more -->
2. CSRF：跨站请求伪造

说明：其实就是网站中的一些提交行为，被黑客利用，在你访问黑客的网站的时候进行操作，会被操作到其他网站上

预防措施：
  - 检测http referer 是否是同域名
  - 避免登录的session长时间存储在客户端中
  - 关键请求使用验证码或者token机制

  其他的一些攻击方法还有 http劫持，界面操作劫持


### 闭包问题

什么是闭包？

专业的说法：**当一个内部函数被其他外部函数之外的变量引用时，就形成了一个闭包。**

简单理解：闭包就是一个具有封闭功能与包裹功能的结构，是为了实现具有私有访问控件的函数，函数可以构成闭包，因为函数内部定义的数据函数外部无法访问，即函数具有封闭性，函数可以封闭代码即具有包裹性，所以函数可以构成闭包。

创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。

闭包的特性：
  - 函数嵌套函数
  - 函数内部可以引用外部的参数和变量
  - 参数和变量不会被垃圾回收机制回收

缺点：
  - 常驻内存，会增大内存使用量，使用不当很容易造成内存泄漏

### 深拷贝和浅拷贝

> 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，修改新对象不会改到原对象

**实现浅拷贝**
```
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = obj1;
obj2.b = 100;
console.log(obj1);
// { a: 10, b: 100, c: 30 } <-- b 被改到了
console.log(obj2);
// { a: 10, b: 100, c: 30 }
```

**实现深拷贝**
```
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };
obj2.b = 100;
console.log(obj1);
// { a: 10, b: 20, c: 30 } <-- b 沒被改到
console.log(obj2);
// { a: 10, b: 100, c: 30 }
```

**深拷贝实现方式**
  - 手动复制方式
  - Object.assign, ES6的新函数
    ```
    var obj1 = { a: 10, b: 20, c: 30 };
    var obj2 = Object.assign({}, obj1);
    obj2.b = 100;
    console.log(obj1);
    // { a: 10, b: 20, c: 30 } <-- 沒被改到
    console.log(obj2);
    // { a: 10, b: 100, c: 30 }
    ```
  - 转成JSON，再转回来
    用JSON.stringify 把对象转成字符串，再用JSON.parse把字符串转成新的对象

    缺点：只有可以转化成JSON格式的对象才可以这样用，像function没办法转成JSON
  - jquery，有提供一个$.extend可以用来做Deep Copy
    1. lodash，也有提供_.cloneDeep用来做 Deep Copy。
    2. 递归实现深拷贝
    ```
    function clone( o ) {
      var temp = {};
      for( var k in o ) {
        if( typeof o[ k ] == 'object' ){
          temp[ k ] = clone( o[ k ] );
        } else {
          temp[ k ] = o[ k ];
        }
      }
      return temp;
    }
    ```

### https 的握手过程

1. 浏览器将自己支持的一套加密规则发送给服务器
2. 服务器从中选出一组加密算法与hash算法，并讲自己的身份信息以整数的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及整数的颁发机构等信息。
3. 浏览器获取网站证书之后浏览器要做一下工作：
  - 验证证书的合法
  - 如果证书受信任，或者是用户接收了不受信任的证书，浏览器会生成一串随机数的密码，并用于证书中提供的公钥加密
  - 使用约定好的hash算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有消息发送给服务器
4. 网站接收浏览器发来的数据之后要做以下操作：
  - 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证hash是否与浏览器发送来的一致
  - 使用密码加密一段握手消息，发送给浏览器
5. 浏览器解密并计算握手消息的hash，如果与服务端发过来的hash一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密

[参考文档](http://blog.jobbole.com/105633/)